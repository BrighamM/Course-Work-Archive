/* the basics for the implementation of this class *

r should never be less than 0 or greater than ROWS-1.

c should never be less than 0 or greater than COLS-1.

hp should never be less than 0.

dir should always be up, dn, lt, or rt.

rank should always be crown, knight, archer, or infantry.

dead is true if and only if hp is 0.

The tla can be any three character string.;

void Move(int dist): Move the unit dist steps in the current dir. 
No error checking is needed, because the game won't let you move
through another unit, on top of another unit, or off the board.

int Attack(): Return the number of hits generated by the unit
in an attack. Roll one six-sided die per hp.  For archers, any
time you roll a 1 or a 2, generate one hit.  For all other units,
any time you roll a 2, 3, or 4, generate one hit.  Return the
total number of hits.

void Suffer(int hits): For infantry and archers, reduce the number
of hp by hits.  For knights and crowns, reduce hp by hits/2.  if
hp becomes 0 or less, set it back to zero and set dead to true.

void Place(int minR,int maxR,int minC,int maxC, SitRep sitrep): set
r to a value greater than or equal to minR and less than or equal
to maxR. set c to a value greater than or equal to minC and less
than or equal to maxC.  [r,c] must be unique for all units that
share the same tla (i.e., each unit must have its own space). Use
the information in the sitrep to help you decide what to do here.

Action Recommendation(SitRep sitrep): return an Action to the game
that is your units recommendation for what it should do next.  This
function should not change any of the private data elements of the
object.  Use the information in the sitrep to help you decide what
to do here.figure this out.

SitRep:  This is a struct that contains a 2D map of Things.  Each
Thing is a struct that provides information about what is in the
space.  It has a What, which is either a space, a rock, or a unit. 
If the What is a unit, the other parts of the Thing (rank, hp, dir,
and tla) are set to the correct information for that unit.

Action:  This stuct is returned by the Recommendation function and
describes what the unit "wants" to do.  It contains an ActionType
(turn, fwd, attack, or nothing).  If the action is to move, then
maxDist indicates how far the unit wants to move, subject of course
to the movement rules in the game.  If the action is to turn, then
dir is set to the desired direction.  If the action is to attack and
the unit is an archer, then ar and ac are set to the location the
archer wishes to attack, subject to the rules of the game.
*/

#ifndef UNIT_H  // this keeps the classes and structs from being defined more
#define UNIT_H  // than once, along with the #endif at the bottom
#include <string>
#include <cstdlib>
#define HORSESPEED 5 //how far the mounted wariors can travel in one action
#define ROWS 30   // board vertical dimension
#define COLS 30   // board horizontal dimension

using namespace std;

// all directions are specified using these
enum Dir{up,dn,lt,rt,none};

// each unit has its own rank
enum Rank{infantry, archer, knight, crown};

// Struct use to represent a box
struct Box
{
  int minr;
  int maxr;
  int minc;
  int maxc;
};

// The Location struct is used in the situation report
struct Location
{
	int r,c;     // to help the unit figure out where to go.
	Dir dirFor;  // This is the direction to go if you want to get to r,c.
};

// These are all the thing a unit can do
enum ActionType {turn,fwd,attack,nothing};

// this struct helps define the details of eadh action
struct Action
{
	ActionType action; // turn, fwd, attack, or nothing
	int maxDist;       // for mounted units, how far you want to move
	Dir dir;           // for turn, which direction to turn to 
	int archerRow, archerCol; // archer target row and col
};

// All things on the board are units, rocks, or empy space
enum ThingType {unit, space, rock};

// this struct is used to completely define any one space on the board
struct Thing
{
	ThingType what;  // a unit, a rock, or an empty space
	Rank rank;       // if it is a unit, this gives its rank
	string playerName; // if it is a unit, this gives its player name
	Dir dir;         // it it is a unit, this gives its current direction
	int hp;          // if it is a unit, this gives its current strength
};

// this struct is given to the Recommendation function when an action is needed
struct SitRep
{
	Thing board[ROWS][COLS];    // a 2d array representing the board
	Location nearestEnemyCrown; // the location and direction of the nearest crown
	Location nearestEnemy;      // the location and direction of the nearest enemy
  Dir anyOpenSpace;           // the direction of an empty space (possibly none) next to you
};

/*
 * This class represents all units on the board.
 */
class Unit
{
public:	
  Unit();

	// accessors
	int getRow();
	int getCol();
	int getHp();
	Dir getDir();
	Rank getRank();
	bool getDead();
	string getPlayerName();

  /*
   * Put unit on the board, inside the bounding box define by min r,c and max r,c.
   * Don't put two units in the same place use the sitrep to figure out what is there.
   */
  virtual Location Place(Box box, SitRep sitrep) = 0;

  /*
   * Tell someone what you want to do. Return an action, as described above.
   */
  virtual Action Recommendation(SitRep sitrep) = 0;

private:
  friend class Hastings;

  // manipulators
  void Turn(Dir newDir); // turn to the indicated direction
  void Move(int dist);   // move exactly this dist with no error checking
  int Attack();          // attack, return hits.  see offical rules for dice rolls
  void Suffer(int hits); // reduce hp by hits, adjust dead if needed

	int r;       // row number
	int c;       // col number
	int hp;      // hit points 
	Dir dir;     // current direction
	Rank rank;   // crown, knight, archer, or infantry;
	bool dead;   // I'm feeling much better; think I'll go for a walk
	string playerName;  // default is "xxx"
};
#endif // end of the #ifndef at the top
